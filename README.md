# 单元测试
用来测试一些小玩意儿，自娱自乐

## 原型模式
如果需要产生同一个类的大量对象实例，这时如果用new出来一个实例，
则每次都会初始化，调用构造方法，浪费大量资源。
于是我们可以用原型模式，先造一个原型对象，然后之后就通过克隆
（浅克隆和深克隆）来创建之后的对象。一个很常见的
使用场景为：for循环内部创建对接来接收集合的对象属性。
## 单例模式
为了防止对象实例的大量创建，导致的系统冗余与混乱，
我们可以用单例模式封闭构造方法，然后内部先实例化一个实例，
只对外暴露一个获取此实例的方法，可以防止实例的大量创造。
## 适配器模式
如果在不改动原有接口或者类的前提下，要用此接口或者类实现其它新需求，或者为已有的两个互不关联的两个接口提供一个协同工作的方式，
则可以构建一个适配器类来实现此接口，同时内部应用另一个类的实例，来实现新需求。
## 策略模式
如果一个方法有多种功能和算法（例如计算器的计算方法，有加减乘除等等），
则可以将算法抽象出来，忽略具体实现，然后定义一些具体算法的实现类，每一个实现类实现一种单一算法。
这样就保证了高扩展性。
## 状态模式
一种最典型的例子就是在很多if-else if语句下，整体不利于代码的阅读和维护，
则可以将if里的条件整合为行为的状态，将if里的主体整合为行为，
具体实现思路为：一个状态接口类，定义会产生的行为，然后构建每种状态的实现类，具体实现某种行为逻辑，
然后构建一个场景类，用来确定状态来实现对应状态下的行为。
## 模板方法模式
当其他方法被继承或实现但唯独某个方法不允许被继承或实现时，可以用此模式，以前的方式是：构建一个父类，然后在定义的很多方法中，将不想被继承的方法用final修饰。
现在可以用接口类的方式写，在接口类中将方法用default修饰，则不会被其实现类实现。
##门面模式
将多个实例的多个方法的调用统一整合在一个类中，统一调度。
即将实例的方法封装在一个类中统一对外提供一个方法。
## 装饰模式
扩展一个类中的功能，装饰者和被装饰者一般都是同一个接口类的实现类，
装饰者内部引用接口类对象，然后在方法中通过内部引用的接口类对象调用被装饰者的方法，
并在此核心方法的基础上扩展内容。如果要装饰或者扩展的种类很多，则可以将装饰者类定义为父类，
然后继承的每个子类负责一种装饰或者扩展。

[![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu)
[![LICENSE](https://img.shields.io/badge/license-Anti%20996-blue.svg)](https://github.com/996icu/996.ICU/blob/master/LICENSE)
